# Database Models Explanation

## Overview
This document explains the database models used in the Metrica Telegram bot. These models follow common software design patterns to separate data storage from business logic.

---

## 1. The `Order` Class (Data Model)

### Purpose
The `Order` class is a **data model** - it represents a single order in your system. Think of it as a blueprint for what an order looks like.

### Key Concepts:

#### **Object-Oriented Programming (OOP)**
```python
class Order:
    def __init__(self, ...):
        # Constructor - creates a new Order object
```

- A **class** is like a template
- An **object** (or **instance**) is a specific order created from that template
- Example: `order1 = Order(client_name="John", ...)` creates one specific order

#### **Instance Variables (Properties)**
```python
self.order_id = order_id
self.client_name = client_name
# etc...
```

These store the data for each order:
- `order_id`: Unique identifier (auto-generated by database)
- `client_name`: Who the order is for
- `description`: What the order is about
- `date`: When the order was placed
- `employee_name`: Who handled the order
- `income_value`: How much money
- `status`: Current state (pending/completed/cancelled)
- `client_contact`: Phone/email
- `created_at`: When record was created

### Key Methods:

#### **`to_dict()` - Serialization**
```python
def to_dict(self) -> Dict:
    return {
        'order_id': self.order_id,
        'client_name': self.client_name,
        # ...
    }
```

**Purpose**: Converts the Order object into a dictionary (Python's key-value structure)

**Why?**: 
- Easy to pass data around
- Can convert to JSON for APIs
- Useful for logging/debugging

**Example**:
```python
order = Order(client_name="John", income_value=100.0)
order_dict = order.to_dict()
# Result: {'order_id': None, 'client_name': 'John', 'income_value': 100.0, ...}
```

#### **`from_dict()` - Deserialization (Class Method)**
```python
@classmethod
def from_dict(cls, data: Dict) -> 'Order':
    return cls(
        order_id=data.get('order_id'),
        client_name=data.get('client_name', ''),
        # ...
    )
```

**Purpose**: Creates an Order object from a dictionary

**`@classmethod` Explanation**:
- Can be called on the class itself, not just an instance
- Example: `Order.from_dict(data)` instead of `order.from_dict(data)`
- The `cls` parameter refers to the class itself

**Why?**: 
- When reading from database/API, you get dictionaries
- This converts them back to Order objects
- Makes code cleaner and type-safe

**Example**:
```python
data = {'client_name': 'John', 'income_value': 100.0}
order = Order.from_dict(data)
# Now you have an Order object!
```

---

## 2. Database Connection Functions

### **`get_db_connection()`**

```python
def get_db_connection(db_path: Optional[str] = None) -> sqlite3.Connection:
    conn = sqlite3.connect(db_path, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    return conn
```

**Purpose**: Creates a connection to the SQLite database

**Key Parameters**:
- `check_same_thread=False`: Allows using the connection from different threads (important for async Telegram bots!)
- `row_factory = sqlite3.Row`: Makes database rows accessible like dictionaries (`row['column_name']`)

**Why a function?**: 
- Centralized connection logic
- Easy to change database location
- Can add connection pooling later

### **`init_db()`**

```python
def init_db(db_path: Optional[str] = None) -> None:
    # Creates the database file if it doesn't exist
    # Creates the 'orders' table with all columns
```

**Purpose**: Sets up the database structure (creates tables)

**What it does**:
1. Creates database file if missing
2. Creates `orders` table with all columns
3. Defines data types (INTEGER, TEXT, REAL)
4. Sets constraints (NOT NULL, PRIMARY KEY, etc.)

**When called**: Once when bot starts (in `bot.py`)

**SQL Explanation**:
```sql
CREATE TABLE IF NOT EXISTS orders (
    order_id INTEGER PRIMARY KEY AUTOINCREMENT,  -- Auto-incrementing ID
    client_name TEXT NOT NULL,                    -- Required text field
    income_value REAL NOT NULL,                   -- Required decimal number
    -- etc...
)
```

---

## 3. The `OrderService` Class (Service Layer)

### Purpose
The `OrderService` class handles **all database operations**. This is called the **Service Layer** pattern.

### Why Separate from Order Class?

**Separation of Concerns**:
- `Order` = Data structure (what an order IS)
- `OrderService` = Operations (what you can DO with orders)

**Benefits**:
- Cleaner code organization
- Easy to test
- Can swap databases without changing Order class
- Single responsibility principle

### Key Methods:

#### **`create_order()` - INSERT**
```python
def create_order(self, order: Order) -> int:
    cursor.execute('''
        INSERT INTO orders (...) VALUES (?, ?, ...)
    ''', (order.client_name, ...))
    order_id = cursor.lastrowid
    conn.commit()
    return order_id
```

**Purpose**: Saves a new order to database

**Flow**:
1. Get database connection
2. Create cursor
3. Execute INSERT SQL with order data
4. Get auto-generated ID (`cursor.lastrowid`)
5. Commit (save) changes
6. Close connection
7. Return the new order ID

**Error Handling**:
- `try/except`: Catches errors
- `rollback()`: Undoes changes if error occurs
- `finally`: Always closes connection (important!)

#### **`get_order_by_id()` - SELECT (single)**
```python
def get_order_by_id(self, order_id: int) -> Optional[Order]:
    cursor.execute('SELECT * FROM orders WHERE order_id = ?', (order_id,))
    row = cursor.fetchone()
    
    if row:
        return Order(...)  # Convert row to Order object
    return None
```

**Purpose**: Retrieves one order by its ID

**Key Concepts**:
- `?` = Placeholder (prevents SQL injection)
- `fetchone()` = Gets one row (or None if not found)
- `Optional[Order]` = Returns Order or None (type hint)

#### **`get_orders_by_date()` - SELECT (multiple)**
```python
def get_orders_by_date(self, date: str) -> List[Order]:
    cursor.execute('SELECT * FROM orders WHERE date = ?', (date,))
    rows = cursor.fetchall()
    
    orders = []
    for row in rows:
        orders.append(Order(...))  # Convert each row to Order
    return orders
```

**Purpose**: Gets all orders for a specific date

**Key Concepts**:
- `fetchall()` = Gets all matching rows
- `List[Order]` = Returns a list of Order objects
- Loop converts each database row to Order object

#### **`update_order()` - UPDATE**
```python
def update_order(self, order: Order) -> bool:
    cursor.execute('''
        UPDATE orders 
        SET client_name = ?, ... 
        WHERE order_id = ?
    ''', (...))
    conn.commit()
    return cursor.rowcount > 0
```

**Purpose**: Updates an existing order

**Key Concepts**:
- `UPDATE ... SET ... WHERE` = SQL update syntax
- `cursor.rowcount` = Number of rows affected (0 if not found)
- Returns `True` if update succeeded, `False` if order not found

#### **`delete_order()` - DELETE**
```python
def delete_order(self, order_id: int) -> bool:
    cursor.execute('DELETE FROM orders WHERE order_id = ?', (order_id,))
    conn.commit()
    return cursor.rowcount > 0
```

**Purpose**: Removes an order from database

---

## 4. How It All Works Together in Telegram Bot

### Flow Example: User Adds an Order

1. **User clicks "Add Order" button**
   ```python
   # callback_handler.py
   callback_data = 'add_order_2024-01-15'
   ```

2. **Form collects data**
   ```python
   # order_form_handler.py
   context.user_data['order_data'] = {
       'client_name': 'John',
       'income_value': 100.0,
       # ...
   }
   ```

3. **Create Order object**
   ```python
   order = Order(
       client_name='John',
       income_value=100.0,
       date='2024-01-15',
       # ...
   )
   ```

4. **Save to database**
   ```python
   order_service = OrderService()
   order_id = order_service.create_order(order)
   # Returns: 1 (the new order ID)
   ```

5. **Display confirmation**
   ```python
   await query.message.reply_text(f"Order #{order_id} created!")
   ```

### Flow Example: Display Orders for Date

1. **User selects date from calendar**
   ```python
   # callback_handler.py
   selected_date = '2024-01-15'
   ```

2. **Load orders from database**
   ```python
   order_service = OrderService()
   orders = order_service.get_orders_by_date(selected_date)
   # Returns: [Order(...), Order(...), ...]
   ```

3. **Display to user**
   ```python
   text = "Orders for this date:\n"
   for order in orders:
       text += f"â€¢ #{order.order_id} - {order.client_name}\n"
   await query.message.reply_text(text)
   ```

---

## 5. Important Patterns Used

### **CRUD Operations**
- **C**reate: `create_order()`
- **R**ead: `get_order_by_id()`, `get_orders_by_date()`
- **U**pdate: `update_order()`
- **D**elete: `delete_order()`

### **Data Access Layer (DAL)**
- Separates database code from business logic
- Makes code testable and maintainable

### **Type Hints**
```python
def create_order(self, order: Order) -> int:
```
- `order: Order` = Parameter must be Order object
- `-> int` = Function returns integer
- Helps catch errors early, improves IDE support

### **Error Handling**
```python
try:
    # Database operation
except Exception as e:
    logger.error(f"Error: {e}")
    raise  # Re-raise to caller
finally:
    conn.close()  # Always close connection
```

---

## 6. Why This Architecture?

### **Benefits**:
1. **Maintainability**: Easy to find and fix bugs
2. **Testability**: Can test OrderService without Telegram bot
3. **Scalability**: Easy to add new features
4. **Reusability**: OrderService can be used in web app, API, etc.
5. **Type Safety**: Type hints prevent common errors

### **Real-World Analogy**:
- **Order** = A recipe card (what ingredients you need)
- **OrderService** = The chef (who actually cooks)
- **Database** = The pantry (where ingredients are stored)

---

## 7. Common Questions

### Q: Why not put database code directly in handlers?
**A**: It would mix concerns. Handlers should handle Telegram interactions, not database details.

### Q: Why use classes instead of just functions?
**A**: Classes group related functionality together and make code more organized.

### Q: What's the difference between `Order` and `OrderService`?
**A**: 
- `Order` = The data (like a form)
- `OrderService` = The operations (like a filing cabinet)

### Q: Why `Optional[Order]` instead of just `Order`?
**A**: The function might not find the order, so it returns `None`. `Optional` means "Order or None".

---

## Summary

- **Order**: Represents order data
- **OrderService**: Handles database operations
- **Functions**: Manage database connections
- **Pattern**: Separation of concerns for clean, maintainable code

This architecture makes your bot professional, testable, and easy to extend!


